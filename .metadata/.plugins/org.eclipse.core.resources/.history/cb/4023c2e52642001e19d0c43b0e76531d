import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

public class swea_1953 {
    static BufferedReader br;
    static StringTokenizer st;
    static int[][] map;
    static int[][] array;
    static int m;
    static int n;
    static boolean[][] visited;
    static int cnt;
    static StringBuilder sb;
    
    static int[][][] deltas ={
    		{{-1,0},{0,-1},{1,0},{0,1}}, //1
            {{-1,0},{0,0},{1,0},{0,0}}, //상하
            {{0,0}, {0,-1}, {0,0},{0,1}},//좌우
            {{-1,0},{0,0},{0,0},{0,1}},//상,우
            {{0,0},{0,0},{1,0},{0,1}},//하,우
            {{0,0},{0,-1},{1,0},{0,0}}, //하,좌
            {{-1,0},{0,-1},{0,0},{0,0}},//상좌
    };

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
       
        int t = Integer.parseInt(br.readLine());
        for(int tc = 1 ; tc <= t ; tc++){
        	cnt= 0;
        	 sb = new StringBuilder();
        	sb.append("#" + tc + " ");
            String[] s = br.readLine().split(" ");
             n = Integer.parseInt(s[0]);
             m = Integer.parseInt(s[1]);
            map = new int[n][m];
            array= new int[n][m];
            int r = Integer.parseInt(s[2]);
            int c = Integer.parseInt(s[3]);
            int l = Integer.parseInt(s[4]);
            visited = new boolean[n][m];
            for(int i=0 ; i < n ; i++){
                st = new StringTokenizer(br.readLine());
                for(int j = 0 ; j < m ; j++){
                    map[i][j] = Integer.parseInt(st.nextToken());
                }
            }

            bfs(r,c,l);
            for(int i=0 ; i < n ; i++) {
            	for(int j =0 ; j < m ; j++) {
            		if(array[i][j] <= l && array[i][j] >= 1) cnt++;
            		System.out.print(array[i][j]+" ");
            	}
            	System.out.println();
            }
            sb.append(cnt);
            System.out.println(sb.toString());
        }
        
    }

    public static void bfs(int r, int c, int hour){
        Queue<int[]> queue = new ArrayDeque<>();
        queue.add(new int[]{r,c});
        visited[r][c] = true;  
        array[r][c] = 1;
        while(!queue.isEmpty()){
            int[] poll = queue.poll(); 
            
            int z = map[poll[0]][poll[1]]-1;
            
            for(int i=0 ; i < 4 ; i++) {
            	int y = poll[0] + deltas[z][i][0];
            	int x = poll[1] + deltas[z][i][1];
            	
            	if(y >= 0  && y < n && x >= 0 && x < m && isconnect(poll[0],poll[1],y,x) && !visited[y][x]) {
            		visited[y][x] = true;
            		queue.add(new int[] {y,x});
            		array[y][x] = array[poll[0]][poll[1]] +1;
            	}
            }
        }
    }
    
    public static boolean isconnect(int y1, int x1, int y2, int x2) {
    	int path1 = map[y1][x1];
    	int path2 = map[y2][x2];
    	if(map[y1][x1]) {
    		
    	}
    }
    
//    Node* find(Node* u) {
//        
//        while (u != u->parent) {
//            s1.push(u); // 부모와 해당 노드가 다르면, 스택에 넣는다. 같으면 그냥 넘어감 
//            u = u->parent; //그리고 노드에 노드의 부모를 넣는다.!!
//        }
//
//        while (!s1.empty()) { //스택에 존재하면(부모오 ㅏ노드가 다른경우), 팝을 해서, 
//            Node* x = s1.top(); s1.pop();
//            x->parent = u; // 팝한 노드의 부모에 부모의 부모를 갱신한 애를 넣는다.
//        }
//        return u;
//    }
    
    public static Edge find(Edge u) {
    	while(u != u.parent) { 
    		stack.push(u); 
    	}
    	ㄱ
    }
}
